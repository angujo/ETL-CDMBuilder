<QueryDefinition>
  <Query>
    select a.patid,
    a.eventdate,
    a.staffid,
    a.value_as_string,
    a.value_as_number,
    a.value_as_date,
    a.unit_source_value,
    right(cast(a.patid as varchar),5) as care_site_id,
    a.constype,
    (cast(a.patid as bigint) * 10000000000) +
    (cast(date_part('year',a.eventdate) as bigint) * 1000000) +
    (cast(date_part('month',a.eventdate) as bigint) * 10000) +
    (cast(date_part('day',a.eventdate) as bigint) * 100) + coalesce(a.constype, 99) as visit_occurrence_id,
    qualifier_source_value,
    case
    when a.qualifier_source_value = 'Not applicable' then 45882470
    when a.qualifier_source_value = 'Abnormal' then 45878745
    when a.qualifier_source_value = 'Absent' then 45884086
    when a.qualifier_source_value = 'High' then 45876384
    when a.qualifier_source_value = 'Low' then 45881666
    when a.qualifier_source_value = 'Negative' then 45878583
    when a.qualifier_source_value = 'Normal' then 45884153
    when a.qualifier_source_value = 'Positive' then 45884084
    when a.qualifier_source_value = 'Present' then 45879438
    when a.qualifier_source_value = 'Trace' then 45881796
    when a.qualifier_source_value = 'Unknown' then 45877986
    when a.qualifier_source_value = 'Very high' then 45879181
    when a.qualifier_source_value = 'Very low' then 45879182
    end as qualifier_concept_id,
    data,
    concat(concat(concat(concat(concat(concat(cast(enttype as varchar), '-'), category), '-'), description), '-') , data)  as source_value
    from
    (
    select a.patid,
    c.eventdate, --Join on line 32 to the Clinical table to get this information
    con.constype,
    c.consid,
    c.staffid,
    a.enttype,
    e.category,
    e.description,
    e.data1 as data,
    case when e.data1_lkup in ('Medical Dictionary', 'Product Dictionary') then null
    else a.data1 --A couple of values in data1 are either read codes or drug codes
    end as value_as_number,
    case when e.data1_lkup = 'Medical Dictionary' then m.read_code
    when e.data1_lkup = 'Product Dictionary' then p.gemscriptcode
    else lu.text
    end as value_as_string,
    case when e.data1_lkup = 'dd/mm/yyyy' then a.data1
    end as value_as_date,
    case when a.enttype in (13,488) then 'kg' --enttype 13 is weight, enttype 488 is weight loss
    when a.enttype = 476 then 'cm' --enttype 476 is waist circumference
    when a.enttype in (119,61,60,120) then 'week' --These enttypes relate to weeks gestation of fetus
    when a.enttype = 14 then 'm' --enttype 14 is height
    else '' --These units have to be hard coded as they do not have a unit lookup
    end as unit_source_value,
    '' as qualifier_source_value,
    m.desc as read_code_description,
    p.productname as gemscript_description,
    e.data_fields
    from {sc}._chunks ch 
    JOIN {sc}.additional a ON a.patid = ch.PERSON_ID and a.enttype not in (72,116,372,78) --These are enttypes where data1 is the value and data2 is the unit
    join {sc}.entity e on a.enttype = e.enttype AND e.data_fields &gt; 0
    join {sc}.clinical c on c.patid = a.patid and c.adid = a.adid
    left join {sc}.lookuptype lt on e.data1_lkup = lt.name
    left join {sc}.lookup lu on lt.lookup_type_id = lu.lookup_type_id and lu.code::text =  a.data1
    left join {sc}.medical m on m.medcode::text = a.data1 and e.data1_lkup = 'Medical Dictionary'
    left join {sc}.product p on p.prodcode::text = a.data1 and e.data1_lkup = 'Product Dictionary'
    left join {sc}.consultation con on a.patid = con.patid and c.consid = con.consid
    where ch.ChunkId = {0}
    group by a.patid, c.eventdate, con.constype, c.consid, c.staffid, e.category, a.enttype, e.description, e.data_fields, e.data1,
     a.data1, lu.text, e.data1_lkup, m.read_code, m.desc, a.data1,
    p.productname, p.gemscriptcode

    UNION

    select a.patid,
    c.eventdate,
    con.constype,
    c.consid,
    c.staffid,
    a.enttype,
    e.category,
    e.description,
    e.data2 as data,
    case when e.data2_lkup in ('Medical Dictionary', 'Product Dictionary') then null
    else  a.data2
    end as value_as_number,
    case when e.data2_lkup = 'Medical Dictionary' then m.read_code
    when e.data2_lkup = 'Product Dictionary' then p.gemscriptcode
    else lu.text
    end as value_as_string,
    case when e.data2_lkup = 'dd/mm/yyyy' then a.data2
    end as value_as_date,
    case when a.enttype = 52 then 'hour' --enttype 52 is sleep pattern and this is asking average hours of sleep
    when a.enttype = 69 then 'week' --enttype 69 is weeks post-natal
    when a.enttype = 150 then 'day' --enttype 150 is days post-natal
    else ''
    end as unit_source_value,
    '' as qualifier_source_value,
    m.desc as read_code_description,
    p.productname as gemscript_description,
    e.data_fields
    from {sc}._chunks ch
    JOIN {sc}.additional a ON a.patid = ch.PERSON_ID and a.enttype not in (72,116,78,60,119,120)
    join {sc}.entity e on a.enttype = e.enttype AND e.data_fields &gt; 1
    left join {sc}.clinical c on c.patid = a.patid and c.adid = a.adid
    left join {sc}.lookuptype lt on e.data2_lkup = lt.name
    left join {sc}.lookup lu on lt.lookup_type_id = lu.lookup_type_id and lu.code::text =  a.data2
    left join {sc}.medical m on m.medcode::text =  a.data2 and e.data2_lkup = 'Medical Dictionary'
    left join {sc}.product p on p.prodcode::text =  a.data2  and e.data2_lkup = 'Product Dictionary'
    left join {sc}.consultation con on a.patid = con.patid and c.consid = con.consid
    where ch.ChunkId = {0}
    group by a.patid, c.eventdate, con.constype, c.consid, c.staffid, e.category, a.enttype, e.description, e.data_fields, e.data2,
     a.data2, lu.text, e.data2_lkup, m.read_code, m.desc, a.data2,
    p.productname, p.gemscriptcode

    UNION

    select a.patid,
    c.eventdate,
    con.constype,
    c.consid,
    c.staffid,
    a.enttype,
    e.category,
    e.description,
    e.data3 as data,
    case when e.data3_lkup in ('Medical Dictionary', 'Product Dictionary') then null
    else  a.data3
    end as value_as_number,
    case when e.data3_lkup = 'Medical Dictionary' then m.read_code
    when e.data3_lkup = 'Product Dictionary' then p.gemscriptcode
    else lu.text
    end as value_as_string,
    case when e.data3_lkup = 'dd/mm/yyyy' then a.data3
    end as value_as_date,
    '' as unit_source_value,
    '' as qualifier_source_value,
    m.desc as read_code_description,
    p.productname as gemscript_description,
    e.data_fields
    from {sc}._chunks ch
    JOIN {sc}.additional a ON a.patid = ch.PERSON_ID and a.enttype not in (372,78,126) --For these enttypes data3 and data4 are coupled and handled farther down in the query
    join {sc}.entity e on a.enttype = e.enttype AND e.data_fields &gt; 2
    left join {sc}.clinical c on c.patid = a.patid and c.adid = a.adid
    left join {sc}.lookuptype lt on e.data3_lkup = lt.name
    left join {sc}.lookup lu on lt.lookup_type_id = lu.lookup_type_id and lu.code::text =  a.data3
    left join {sc}.medical m on m.medcode::text =  a.data3 and e.data3_lkup = 'Medical Dictionary'
    left join {sc}.product p on p.prodcode::text =  a.data3 and e.data3_lkup = 'Product Dictionary'
    left join {sc}.consultation con on a.patid = con.patid and c.consid = con.consid 
    where ch.ChunkId = {0}
    group by a.patid, c.eventdate, con.constype, c.consid, c.staffid, e.category, a.enttype, e.description, e.data_fields, e.data3,
     a.data3, lu.text, e.data3_lkup, m.read_code, m.desc, a.data3,
    p.productname, p.gemscriptcode

    UNION

    select a.patid,
    c.eventdate,
    con.constype,
    c.consid,
    c.staffid,
    a.enttype,
    e.category,
    e.description,
    e.data4 as data,
    case when e.data4_lkup in ('Medical Dictionary', 'Product Dictionary') then null
    else  a.data4
    end as value_as_number,
    case when e.data4_lkup = 'Medical Dictionary' then m.read_code
    when e.data4_lkup = 'Product Dictionary' then p.gemscriptcode
    else lu.text
    end as value_as_string,
    case when e.data4_lkup = 'dd/mm/yyyy' then a.data4
    end as value_as_date,
    '' as unit_source_value,
    '' as qualifier_source_value,
    m.desc as read_code_description,
    p.productname as gemscript_description,
    e.data_fields
    from {sc}._chunks ch
    JOIN {sc}.additional a ON a.patid = ch.PERSON_ID and a.enttype not in (372,78,126) --For these enttypes data3 and data4 are coupled and handled farther down in the query
    join {sc}.entity e on a.enttype = e.enttype AND e.data_fields &gt; 3
    left join {sc}.clinical c on c.patid = a.patid and c.adid = a.adid
    left join {sc}.lookuptype lt on e.data4_lkup = lt.name
    left join {sc}.lookup lu on lt.lookup_type_id = lu.lookup_type_id and lu.code::text =  a.data4
    left join {sc}.medical m on m.medcode::text =  a.data4 and e.data4_lkup = 'Medical Dictionary'
    left join {sc}.product p on p.prodcode::text =  a.data4 and e.data4_lkup = 'Product Dictionary'
    left join {sc}.consultation con on a.patid = con.patid and c.consid = con.consid   
    where ch.ChunkId = {0}
    group by a.patid, c.eventdate, con.constype, c.consid, c.staffid, e.category, a.enttype, e.description, e.data_fields, e.data4,
     a.data4, lu.text, e.data4_lkup, m.read_code, m.desc, a.data4, p.productname, p.gemscriptcode

    UNION

    select a.patid,
    c.eventdate,
    con.constype,
    c.consid,
    c.staffid,
    a.enttype,
    e.category,
    e.description,
    e.data5 as data,
    case when e.data5_lkup in ('Medical Dictionary', 'Product Dictionary') then null
    else  a.data5
    end as value_as_number,
    case when e.data5_lkup = 'Medical Dictionary' then m.read_code
    when e.data5_lkup = 'Product Dictionary' then p.gemscriptcode
    else lu.text
    end as value_as_string,
    case when e.data5_lkup = 'dd/mm/yyyy' then a.data5
    end as value_as_date,
    '' as unit_source_value,
    '' as qualifier_source_value,
    m.desc as read_code_description,
    p.productname as gemscript_description,
    e.data_fields
    from {sc}._chunks ch
    JOIN {sc}.additional a ON a.patid = ch.PERSON_ID and a.enttype not in (78) --For this enttype data5 and data6 are coupled and handled farther down in the query
    left join {sc}.clinical c on c.patid = a.patid and c.adid = a.adid
    join {sc}.entity e on a.enttype = e.enttype AND e.data_fields &gt; 4
    left join {sc}.lookuptype lt on e.data5_lkup = lt.name
    left join {sc}.lookup lu on lt.lookup_type_id = lu.lookup_type_id and lu.code::text =  a.data5
    left join {sc}.medical m on m.medcode::text =  a.data5 and e.data5_lkup = 'Medical Dictionary'
    left join {sc}.product p on p.prodcode::text =  a.data5 and e.data5_lkup = 'Product Dictionary'
    left join {sc}.consultation con on a.patid = con.patid and c.consid = con.consid  
    where ch.ChunkId = {0}
    group by a.patid, c.eventdate, con.constype, c.consid, c.staffid, e.category, a.enttype, e.description, e.data_fields, e.data5,
     a.data5, lu.text, e.data5_lkup, m.read_code, m.desc, a.data5, p.productname, p.gemscriptcode

    UNION

    select a.patid,
    c.eventdate,
    con.constype,
    c.consid,
    c.staffid,
    a.enttype,
    e.category,
    e.description,
    e.data6 as data,
    case when e.data6_lkup in ('Medical Dictionary', 'Product Dictionary') then null
    else  a.data6
    end as value_as_number,
    case when e.data6_lkup = 'Medical Dictionary' then m.read_code
    when e.data6_lkup = 'Product Dictionary' then p.gemscriptcode
    else lu.text
    end as value_as_string,
    case when e.data6_lkup = 'dd/mm/yyyy' then a.data6
    end as value_as_date,
    '' as unit_source_value,
    '' as qualifier_source_value,
    m.desc as read_code_description,
    p.productname as gemscript_description,
    e.data_fields
    from {sc}._chunks ch
    JOIN {sc}.additional a ON a.patid = ch.PERSON_ID and a.enttype not in (78) --For this enttype data5 and data6 are coupled and handled farther down in the query
    join {sc}.entity e on a.enttype = e.enttype AND e.data_fields &gt; 5
    left join {sc}.clinical c on c.patid = a.patid and c.adid = a.adid
    left join {sc}.lookuptype lt on e.data6_lkup = lt.name
    left join {sc}.lookup lu on lt.lookup_type_id = lu.lookup_type_id and lu.code::text =  a.data6
    left join {sc}.medical m on m.medcode::text =  a.data6 and e.data6_lkup = 'Medical Dictionary'
    left join {sc}.product p on p.prodcode::text =  a.data6 and e.data6_lkup = 'Product Dictionary'
    left join {sc}.consultation con on a.patid = con.patid and c.consid = con.consid 
    where ch.ChunkId = {0}
    group by a.patid, c.eventdate, con.constype, c.consid, c.staffid, e.category, a.enttype, e.description, e.data_fields, e.data6,
     a.data6, lu.text, e.data6_lkup, m.read_code, m.desc, a.data6, p.productname, p.gemscriptcode

    UNION

    select a.patid,
    c.eventdate,
    con.constype,
    c.consid,
    c.staffid,
    a.enttype,
    e.category,
    e.description,
    e.data7 as data,
    case when e.data7_lkup in ('Medical Dictionary', 'Product Dictionary') then null
    else  a.data7
    end as value_as_number,
    case when e.data7_lkup = 'Medical Dictionary' then m.read_code
    when e.data7_lkup = 'Product Dictionary' then p.gemscriptcode
    else lu.text
    end as value_as_string,
    case when e.data7_lkup = 'dd/mm/yyyy' then a.data7
    end as value_as_date,
    '' as unit_source_value,
    '' as qualifier_source_value,
    m.desc as read_code_description,
    p.productname as gemscript_description,
    e.data_fields
    from {sc}._chunks ch
    JOIN {sc}.additional a ON a.patid = ch.PERSON_ID
    join {sc}.entity e on a.enttype = e.enttype AND e.data_fields &gt; 6
    left join {sc}.clinical c on c.patid = a.patid and c.adid = a.adid
    left join {sc}.lookuptype lt on e.data7_lkup = lt.name
    left join {sc}.lookup lu on lt.lookup_type_id = lu.lookup_type_id and lu.code::text =  a.data7
    left join {sc}.medical m    on m.medcode::text =  a.data7 and e.data7_lkup = 'Medical Dictionary'
    left join {sc}.product p on p.prodcode::text =  a.data7 and e.data7_lkup = 'Product Dictionary'
    left join {sc}.consultation con on a.patid = con.patid and c.consid = con.consid   
    where ch.ChunkId = {0}
    group by a.patid, c.eventdate, con.constype, c.consid, c.staffid, e.category, a.enttype, e.description, e.data_fields, e.data7,
     a.data7, lu.text, e.data7_lkup, m.read_code, m.desc, a.data7,
    p.productname, p.gemscriptcode

    UNION

    select a.patid,
    c.eventdate,
    con.constype,
    c.consid,
    c.staffid,
    a.enttype,
    e.category,
    e.description,
    e.data1 as data,
    case when e.data1_lkup in ('Medical Dictionary', 'Product Dictionary') then null
    else  a.data1
    end as value_as_number,
    case when e.data1_lkup = 'Medical Dictionary' then m.read_code
    when e.data1_lkup = 'Product Dictionary' then p.gemscriptcode
    else lu.text
    end as value_as_string,
    case when e.data1_lkup = 'dd/mm/yyyy' then a.data1
    end as value_as_date,
    lu2.text as unit_source_value,
    '' as qualifier_source_value,
    m.desc as read_code_description,
    p.productname as gemscript_description,
    e.data_fields
    from {sc}._chunks ch
    JOIN {sc}.additional a ON a.patid = ch.PERSON_ID AND a.enttype in (72,116,78) --For these enttypes data1 is the value and data2 is the unit
    join {sc}.entity e on a.enttype = e.enttype
    left join {sc}.clinical c on c.patid = a.patid and c.adid = a.adid
    left join {sc}.lookuptype lt on e.data1_lkup = lt.name
    left join {sc}.lookup lu on lt.lookup_type_id = lu.lookup_type_id and lu.code::text =  a.data1
    left join {sc}.lookuptype lt2 on e.data2_lkup = lt2.name
    left join {sc}.lookup lu2 on lt2.lookup_type_id = lu2.lookup_type_id and lu2.code::text =  a.data2
    left join {sc}.medical m on m.medcode::text =  a.data1 and e.data1_lkup = 'Medical Dictionary'
    left join {sc}.product p on p.prodcode::text =  a.data1 and e.data1_lkup = 'Product Dictionary'
    left join {sc}.consultation con on a.patid = con.patid and c.consid = con.consid
    where ch.ChunkId = {0}
    group by a.patid, c.eventdate, con.constype, c.consid, c.staffid, e.category, a.enttype, e.description, e.data_fields, e.data1,
     a.data1, lu.text, e.data1_lkup, m.read_code, m.desc, a.data1,
    p.productname, p.gemscriptcode, lu2.text

    UNION

    select a.patid,
    c.eventdate,
    con.constype,
    c.consid,
    c.staffid,
    a.enttype,
    e.category,
    e.description,
    e.data3 as data,
    case when e.data3_lkup in ('Medical Dictionary', 'Product Dictionary') then null
    else  a.data3
    end as value_as_number,
    case when e.data3_lkup = 'Medical Dictionary' then m.read_code
    when e.data3_lkup = 'Product Dictionary' then p.gemscriptcode
    else lu.text
    end as value_as_string,
    case when e.data3_lkup = 'dd/mm/yyyy' then a.data3
    end as value_as_date,
    lu2.text as unit_source_value,
    '' as qualifier_source_value,
    m.desc as read_code_description,
    p.productname as gemscript_description,
    e.data_fields
    from {sc}._chunks ch
    JOIN {sc}.additional a ON a.patid = ch.PERSON_ID AND a.enttype in (126,78) --For these datatypes data3 is the value and data4 is the unit
    join {sc}.entity e on a.enttype = e.enttype
    left join {sc}.clinical c on c.patid = a.patid and c.adid = a.adid
    left join {sc}.lookuptype lt on e.data3_lkup = lt.name
    left join {sc}.lookup lu on lt.lookup_type_id = lu.lookup_type_id and lu.code::text =  a.data3
    left join {sc}.lookuptype lt2 on e.data4_lkup = lt2.name
    left join {sc}.lookup lu2 on lt2.lookup_type_id = lu2.lookup_type_id and lu2.code::text =  a.data4
    left join {sc}.medical m on m.medcode::text =  a.data3 and e.data1_lkup = 'Medical Dictionary'
    left join {sc}.product p on p.prodcode::text =  a.data3 and e.data1_lkup = 'Product Dictionary'
    left join {sc}.consultation con on a.patid = con.patid and c.consid = con.consid
    where ch.ChunkId = {0}
    group by a.patid, c.eventdate, con.constype, c.consid, c.staffid, e.category, a.enttype, e.description, e.data_fields, e.data3,
     a.data3, lu.text, e.data3_lkup, m.read_code, m.desc, a.data3,
    p.productname, p.gemscriptcode, lu2.text

    UNION

    select a.patid,
    c.eventdate,
    con.constype,
    c.consid,
    c.staffid,
    a.enttype,
    e.category,
    e.description,
    e.data5 as data,
    case when e.data5_lkup in ('Medical Dictionary', 'Product Dictionary') then null
    else  a.data5
    end as value_as_number,
    case when e.data5_lkup = 'Medical Dictionary' then m.read_code
    when e.data5_lkup = 'Product Dictionary' then p.gemscriptcode
    else lu.text
    end as value_as_string,
    case when e.data5_lkup = 'dd/mm/yyyy' then a.data5
    end as value_as_date,
    lu2.text as unit_source_value,
    '' as qualifier_source_value,
    m.desc as read_code_description,
    p.productname as gemscript_description,
    e.data_fields
    from {sc}._chunks ch
    JOIN {sc}.additional a ON a.patid = ch.PERSON_ID AND a.enttype in (78) --For this enttype data5 is the value and data6 is the unit
    join {sc}.entity e on a.enttype = e.enttype and e.data1_lkup = 'Medical Dictionary' and e.data1_lkup = 'Product Dictionary'
    left join {sc}.clinical c on c.patid = a.patid and c.adid = a.adid
    left join {sc}.lookuptype lt on e.data5_lkup = lt.name
    left join {sc}.lookup lu on lt.lookup_type_id = lu.lookup_type_id and lu.code::text =  a.data5
    left join {sc}.lookuptype lt2 on e.data6_lkup = lt2.name
    left join {sc}.lookup lu2 on lt2.lookup_type_id = lu2.lookup_type_id and lu2.code::text =  a.data6
    left join {sc}.medical m on m.medcode::text =  a.data5
    left join {sc}.product p on p.prodcode::text =  a.data5
    left join {sc}.consultation con on a.patid = con.patid and c.consid = con.consid
    where ch.ChunkId = {0}
    group by a.patid, c.eventdate, con.constype, c.consid, c.staffid, e.category, a.enttype, e.description, e.data_fields, e.data5,
     a.data5, lu.text, e.data5_lkup, m.read_code, m.desc, a.data5,
    p.productname, p.gemscriptcode, lu2.text

    UNION

    select a.patid,
    c.eventdate,
    con.constype,
    c.consid,
    c.staffid,
    a.enttype,
    e.category,
    e.description,
    sm.scoringmethod as data,
    a.data1 as value_as_number,
    '' as value_as_string,
    case when e.data1_lkup = 'dd/mm/yyyy' then a.data1
    end as value_as_date,
    '' as unit_source_value,
    lu4.text as qualifier_source_value,
    '' as read_code_description,
    '' as gemscript_description,
    e.data_fields
    from {sc}._chunks ch
    JOIN {sc}.additional a ON a.patid = ch.PERSON_ID AND a.enttype in (372) --This enttype is for the results of scores and questionnaires
    join {sc}.entity e on a.enttype = e.enttype
    left join {sc}.clinical c on c.patid = a.patid and c.adid = a.adid
    left join {sc}.scoringmethod sm on a.data3 = sm.code::text
    left join {sc}.lookuptype lt4 on e.data4_lkup = lt4.name
    left join {sc}.lookup lu4 on lt4.lookup_type_id = lu4.lookup_type_id and lu4.code::text =  a.data4
    left join {sc}.consultation con on a.patid = con.patid and c.consid = con.consid
    where ch.ChunkId = {0}
    group by a.patid, c.eventdate, con.constype, c.consid, c.staffid, e.category, a.enttype, e.description, e.data_fields, sm.scoringmethod,
     a.data1, lu4.text, e.data4_lkup, a.data1, e.data1_lkup
    ) as a
    where a.eventdate is not NULL order by a.patid
  </Query>
  <Observation>
    <ObservationDefinition>
      <PersonId>patid</PersonId>
      <StartDate>eventdate</StartDate>
      <ProviderId>staffid</ProviderId>
      <VisitDetailId>visit_occurrence_id</VisitDetailId>
      <QualifierConceptId>qualifier_concept_id</QualifierConceptId>
      <QualifierSourceValue>qualifier_source_value</QualifierSourceValue>
      <ValuesAsString>
        <string>value_as_string</string>
      </ValuesAsString>
      <ValuesAsNumber>
           <string>value_as_number</string>
         </ValuesAsNumber>
      <AdditionalFields>
        <string>data</string>
        <string>constype</string>
      </AdditionalFields>
      <Concepts>
        <Concept>
          <ConceptIdMappers>
            <Mapper>
              <Lookup>Additional</Lookup>
            </Mapper>
          </ConceptIdMappers>
          <Fields>
            <Field key="source_value" defaultTypeId="38000280" isNullable="true"/>
          </Fields>
        </Concept>
        <Concept>
          <ConceptIdMappers>
            <Mapper>
              <Lookup>Units</Lookup>
            </Mapper>
          </ConceptIdMappers>
          <Fields>
            <Field key="unit_source_value" defaultTypeId="0" />
          </Fields>
        </Concept>
      </Concepts>
    </ObservationDefinition>
  </Observation>
</QueryDefinition>